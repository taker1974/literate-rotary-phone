// https://habr.com/ru/articles/485678/
Назвать методы Object
toString()
equals()
hashCode()
wait()
notify()
notifyAll()
getClass()

Что такое string-pool? В чем отличие cоздания строки через new от литерала? Что такое String.intern()?
string-pool — структура в памяти, хранящая массив всех строк-литералов программы.
String.intern(), соответственно, вернет строку из пула, при наличии таковой. Полезно при сравнениях вида:
new String("hello").intern() == new String("hello").intern()
Т.к без интернирования пришлось бы сравнивать строки через equals, что может быть медленнее при наличии длинных строк. В данном случае возвращается ссылка на один и тот же объект строки из пула, и проверка проходит с true.

Почему хранить пароль предпочтительнее в char[]/byte[], а не в String? (**)
Строка в виде литерала сразу раскрывает пароль, плюс она всегда хранится в string-пуле
byte[]/char[] возможно сбросить после использования, и удалить все ссылки на него

Привести пример плохой реализации hashCode()
Метод, возвращающий константу, или значения хэшкодов с неравномерным распределением, приводящим к коллизиям

Примитивы, врапперы. Package/unpackage (boxing/unboxing)
Типы примитивы не создаются в куче, их жизненный цикл ограничен жизненным циклом стек-фрейма
Package — создание типа-обертки в хипе для аналогичного типа-примитива, например при объявлении аргумента как Integer, и при передаче int в качестве аргумента. Unpackage — обратная операция

Сравнение по == и по equals
Сравнение по "==" — сравнение по ссылкам
Сравнение по «equals» — если переопределен equals, то это сравнение эквивалентности объектов по их полям, если нет — по ссылкам на объекты

Свойства, которым должен удовлетворять equals
Рефлексивность: a==a
Симметричность: a==b, b==a
Транзитивность: a==b, b==c, a==c
Консистентность: Множественные вызовы equals должны возвращать один и тот же результат

Отличия String/StringBuilder/StringBuffer
String — иммутабельный байтовый массив
StringBuilder — helper-класс для построения строк, не предоставляет гарантий синхронизации
StringBuffer — то же, что и StringBuilder, с synchronized методами

Приведите пример нарушения симметрии equals
Создать класс Point2D c полями x,y: double
Унаследовать от него класс ColoredPoint2D c доп. полем color
a: Point2D
b: ColoredPoint2D
a.equals(b), !b.equals(a)

Interface vs Abstract Class
Интерфейс есть средство наследования API, абстрактный класс — средство наследования реализации
Через интерфейсы возможно осуществлять множественное наследование, абстрактный класс можно наследовать в одном экземпляре.
В интерфейсе нет возможности определить поля и конструкторы

override vs overload
override — возможность переопределениия поведения метода в типах-потомках
overload — возможность переопределять метод с одним именем, но разным набором аргументов

Как в Java сделать утечку памяти?
Используя самописный класс стека, при выполнении операции pop() не присваивать предыдущей ссылке значение null.
Также можно неверно использовать HashMap вместо WeakHashMap для кэширования чего-нибудь большого, например картинок ваших товаров, пользователей и.т.д в. Т.к ссылки на ключи сильные (strong references), значения по этим ключам будут висеть в хипе до морковкиного заговенья следующей перезагрузки jvm процесса или удаления ключа из мапы и обнуления ссылки на него. Вообще, кэширование — тема для отдельного разговора

Как вернуть псевдо-случайную последовательность целых чисел/чисел с плавающей запятой?
java.util.Random

В чем проблемы Random?
Random возвращает псевдо-случайную числовую последовательность, основанную на линейном конгруэнтном методе и seed'е, основанном на timestamp'е создания j.u.Random.
Соотвественно, зная время создания, можно предсказать такую последовательность. Такой генератор является детерминированным, и криптографически нестойким. Для исправления этого лучше использовать SecureRandom

GC и различные его виды в JVM. Какой объект считать достижимым. Как происходит сборка мусора (своими словами)
Виды GC:
Serial Stop the World
Parallel
CMS (В чем недостаток по сравнению с Parallel?)
G1 (Назвать отличие от CMS)
Shenandoah
Если объект является достижимым из стека или статической области, то он не поддается сборке мусора

Java 8: стримы, функциональные интерфейсы, Optional
Stream — интерфейс, предоставляющий функциональные возможности обработки коллекций (filter, map, reduce, peek)
Операции на стримах делятся на терминальные и нетерминальные. Нетерминальные операции модифицируют pipeline операций над коллекцией, при этом не изменяя саму коллекцию, терминальные (например, collect) — проводят действия pipeline'а, возвращают результат и закрывают Stream.
FunctionalInterface — аннотация, предоставляющая возможность использовать лямбды на месте интерфейсов (например, при передаче лямбды в качестве аргумента в метод)
Optional — интерфейс, предохраняющий пользовательский код от nullable ссылок. Оборачивает исходный nullable объект, и предоставляет возможность понять, хранит ли non-nullable объект или нет.

Java 8: Что такое capturing/non-capturing lambda
capturing lambda захватывает локальные переменные/аргументы/поля объекта из внешнего скоупа
non-capturing lambda — не захватывает контекст внешнего скоупа, не инстанцируется каждый раз при использовании

Новые возможности Java 9 — 11
Новые методы в String
Java 9: Модульность
Java 9: Методы в Objects: requireNonNullElse() и requireNonNullElseGet()
Java 9: List.of(), Set.of(), Map.of(), Map.ofEntries()
Java 9: Optional.ifPresentOrElse(), Optional.stream()
Java 10: var type-inference
Java 11: Files.readString(), Files.writeString()
Java 11: Local-Variable Syntax for Lambda Parameters — выведение типов у var-аргументов в лямбда-параметрах
Java 11: JEP 321: HTTP Client
Можно как бонус назвать какие-нибудь:
JEP 328: Flight Recorder
JEP 335: Deprecate the Nashorn JavaScript Engine
JEP 320: Remove the Java EE and CORBA Modules
но это совершенно необязательно, покажет лишь вашу въедливость при чтении JDK'шных Release Notes :)

Generics: В чем преимущество, как работают? Что такое type-erasure? В чем отличие от шаблонов C++?
Типы дженерики обеспечивают параметрический полиморфизм, т.е выполнение идентичного кода для различных типов. Типичный пример — коллекции, итераторы
type-erasure — это стирание информации о типе-параметре в runtime. Таким образом, в байт-коде мы увидим List, Set вместо List<Integer>, Set<Integer>, ну и type-cast'ы при необходимости
В отличие от дженериков в Java, в С++ шаблоны в итоге приводят к компиляции метода или типа для каждого специфицированного типа параметра (специализация шаблона). Да простят меня здесь адепты С++.

Generics: Метод принимает ссылку на List<Parent>. Child наследуется от Parent. Можно ли в метод передать List<Child>?
В типе аргумента нужно указать List<? extends Parent>

Generics: Ковариантность/контравариантность. Спросить про принцип PECS как бонус
Ковариантность — List<? extends T>, если B extends T, то и List<B> extends List<T>
Контраваринтность — List<? super T>, если B super T, то и List<B> super List<T>
PECS — Producer-Extends-Consumer-Super, метод отдаёт ковариантный тип, принимает контравариантный (прим. автора — последнее интуитивно не очень понятно)

Регионы памяти в JVM
Java 8: Metaspace, Old Generation, Young Generation (Eden Space/Survivor Space), Stack, Constant Pool, Code Cache, GC Area. Hard-references, weak references, soft-references, phantom-references
Hard-references — стандартные ссылки на объекты, которые становится eligible for collection после недостижимости из root set
Weak-references — объекты могут быть удалены при наличии слабой ссылки на него в любое время
Soft-references — объекты могут удалятся GC при недостатке памяти
Phantom-references — объекты не доступны напрямую по ссылкам, перед удалением помещаются в очередь на удаление. Нужны для более безопасной финализации ссылок (вместо finalize)

Рассказать про classloader'ы и их иерархию. Из за чего, например, может возникать NoClassDefFoundError, NoSuchMethodError?
Иерархия classloader'ов
Bootstrap
System
Application
NoClassDefFoundError может возникнуть, если нужной библиотеки с этим классом нет в classpath
NoSuchMethodError может возникнуть из-за несовместимости ваших библиотек, если зависимая библиотека A вызывает метод из старой версии библиотеки B, но в classpath есть более новая версия библиотеки B, c другой сигнатурой этого метода

Какими способами можно сконструировать объект в Java?
Через конструктор
Через статический factory-method
Через паттерн Builder

Как идентифицируется класс в Java?
По его FQDN и classloader'у

Bytecode: назовите какие-нибудь инструкции и опишите их
Здесь только краткий список команд:
aload
aconst
astore
Описать принцип действия стековой машины как бонус. Допустим, на примере вызова метода.

Bytecode: invokevirtual, invokestatic, invokespecial — когда используются?
invokevirtual — вызовы методов (в Java все методы виртуальные)
invokestatic — вызовы статических методов
invokespecial — вызовы конструкторов и приватных методов
